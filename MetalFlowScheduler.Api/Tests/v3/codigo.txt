using Google.OrTools.Sat;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Globalization; // Para formatação de datas
using Newtonsoft.Json; // Adicionar referência via NuGet

// --- Estruturas de Dados (sem alterações) ---

public class Product
{
    public string Name { get; }
    public int Quantity { get; }
    public int Price { get; } // Lucro se finalizado no prazo
    public List<string> Route { get; } // Sequência de TIPOS de operação (máquina)

    public Product(string name, int quantity, int price, List<string> route)
    {
        Name = name;
        Quantity = quantity;
        Price = price;
        Route = route ?? new List<string>();
    }
}

public class Machine
{
    public string Name { get; }      // Identificador único da máquina (ex: "Fusao_M1_L1")
    public string Type { get; }      // Tipo funcional da máquina (ex: "Fusao")
    public decimal Capacity { get; } // Capacidade de produção por hora
    public int SetupTime { get; }   // Tempo de setup em minutos

    public Machine(string name, string type, decimal capacity, int setupTime)
    {
        Name = name;
        Type = type;
        Capacity = capacity;
        SetupTime = setupTime;
    }

    public override string ToString() => Name;
}

public class WorkCenter
{
    public string Name { get; }
    public List<Machine> Machines { get; }
    // Mapeia tipo de máquina para máquinas desse tipo neste WC
    public Dictionary<string, List<Machine>> MachinesByType { get; }

    public WorkCenter(string name, List<Machine> machines)
    {
        Name = name;
        Machines = machines ?? new List<Machine>();
        MachinesByType = Machines
            .GroupBy(m => m.Type)
            .ToDictionary(g => g.Key, g => g.ToList());
    }

    // Helper para encontrar máquinas de um tipo específico neste WC
    public List<Machine> GetMachinesOfType(string machineType)
    {
        return MachinesByType.TryGetValue(machineType, out var list) ? list : new List<Machine>();
    }

    // Helper para obter o setup time máximo para um tipo de máquina neste WC
    public int GetMaxSetupTimeForType(string machineType)
    {
        if (MachinesByType.TryGetValue(machineType, out var machinesOfType))
        {
            return machinesOfType.Any() ? machinesOfType.Max(m => m.SetupTime) : 0;
        }
        return 0;
    }

    // Helper para obter a capacidade total para um tipo de máquina neste WC
    public decimal GetTotalCapacityForType(string machineType)
    {
        if (MachinesByType.TryGetValue(machineType, out var machinesOfType))
        {
            return machinesOfType.Sum(m => m.Capacity);
        }
        return 0M;
    }
}

public class Line
{
    public string Name { get; }
    public List<WorkCenter> WorkCenters { get; } // Sequência ordenada de WCs na linha
    public HashSet<string> AllowedProducts { get; } // Produtos permitidos nesta Linha

    public Line(string name, List<WorkCenter> workCenters, IEnumerable<string> allowedProducts)
    {
        Name = name;
        WorkCenters = workCenters ?? new List<WorkCenter>();
        AllowedProducts = new HashSet<string>(allowedProducts);
    }

    // Helper para encontrar todas as máquinas em uma linha
    public List<Machine> GetAllMachines()
    {
        return WorkCenters.SelectMany(wc => wc.Machines).ToList();
    }

    // Helper para encontrar máquinas elegíveis para um tipo de operação específico NESTA LINHA
    // Retorna um dicionário mapeando WC -> Lista de Máquinas elegíveis naquele WC
    public Dictionary<WorkCenter, List<Machine>> GetEligibleMachinesForTypeByWC(string machineType)
    {
        var result = new Dictionary<WorkCenter, List<Machine>>();
        foreach (var wc in WorkCenters)
        {
            var machinesInWc = wc.GetMachinesOfType(machineType);
            if (machinesInWc.Any())
            {
                result[wc] = machinesInWc;
            }
        }
        return result;
    }
}

// --- Estruturas para Saída JSON (sem alterações) ---
public class TimelineOutput
{
    public List<LineEntry> TimeLine { get; set; } = new List<LineEntry>();
}

public class LineEntry
{
    public string Line { get; set; }
    public string StartTime { get; set; }
    public string EndTime { get; set; }
    public double Delay { get; set; } // Atraso em minutos
    public List<WorkCenterEntry> WorkCenters { get; set; } = new List<WorkCenterEntry>();
}

public class WorkCenterEntry
{
    public string WorkCenter { get; set; }
    public string StartTime { get; set; }
    public string EndTime { get; set; }
    public double Delay { get; set; } // Atraso em minutos
    public List<MachineEntry> Machines { get; set; } = new List<MachineEntry>();
}

public class MachineEntry
{
    public string Product { get; set; }
    public string Machine { get; set; }
    public string StartTime { get; set; }
    public string EndTime { get; set; }
    public double Delay { get; set; } // Atraso em minutos
}


class Program
{
    // Constante para formatação de data/hora
    private const string DateTimeFormat = "dd/MM/yyyy HH:mm";

    static void Main()
    {
        // --- Dados de Entrada (Fácil Configuração Visual) ---
        DateTime startDate = new DateTime(2025, 4, 29, 6, 0, 0);
        int planningHorizonMinutes = 2 * 24 * 60; // Horizonte de planejamento (ex: 2 dias)

        // --- FLAG DE CONTROLE DE ATRASO ---
        bool permitirAtraso = true; // Define se produtos podem terminar após o deadline (se começarem antes)
        // ------------------------------------

        DateTime deadlineDate = new DateTime(2025, 5, 1, 16, 0, 0); // Deadline
        int deadlineMinutes = (int)(deadlineDate - startDate).TotalMinutes;
        if (deadlineMinutes <= 0)
        {
            Console.WriteLine("Erro: Deadline deve ser posterior à data de início.");
            return;
        }
        if (deadlineMinutes > planningHorizonMinutes)
        {
            Console.WriteLine($"Aviso: Deadline ({deadlineDate}) está além do horizonte de planejamento ({startDate.AddMinutes(planningHorizonMinutes)}). Ajustando horizonte.");
            planningHorizonMinutes = deadlineMinutes + (6 * 60); // Adiciona margem
        }


        // --- Definição das Máquinas ---
        // Linha 1
        var fusaoM1_L1 = new Machine("Fusao_M1_L1", "Fusao", 10M, 15); // Setup 15 min
        var fusaoM2_L1 = new Machine("Fusao_M2_L1", "Fusao", 10M, 10); // Setup 10 min -> Max Setup Fusao L1 = 15
        var aquecM1_L1 = new Machine("Aquec_M1_L1", "Aquecimento", 10M, 20); // Setup 20 min -> Max Setup Aquec L1 = 20
        var extrusM1_L1 = new Machine("Extrus_M1_L1", "Extrusao", 10M, 15); // Setup 15 min -> Max Setup Extrus L1 = 15
        var corteM1_L1 = new Machine("Corte_M1_L1", "Corte", 10M, 5);  // Setup 5 min
        var corteM2_L1 = new Machine("Corte_M2_L1", "Corte", 10M, 15); // Setup 15 min -> Max Setup Corte L1 = 15

        // Linha 2
        var fusaoM1_L2 = new Machine("Fusao_M1_L2", "Fusao", 9M, 18); // Setup 18 min -> Max Setup Fusao L2 = 18
        var aquecM1_L2 = new Machine("Aquec_M1_L2", "Aquecimento", 11M, 12); // Setup 12 min -> Max Setup Aquec L2 = 12
        var extrusM1_L2 = new Machine("Extrus_M1_L2", "Extrusao", 10M, 15); // Setup 15 min -> Max Setup Extrus L2 = 15
        var corteM1_L2 = new Machine("Corte_M1_L2", "Corte", 14M, 6); // Setup 6 min -> Max Setup Corte L2 = 6

        // --- Definição dos WorkCenters ---
        var wc_Aciaria_L1 = new WorkCenter("Aciaria_L1", new List<Machine> { fusaoM1_L1, fusaoM2_L1, aquecM1_L1 });
        var wc_Lam_L1 = new WorkCenter("Laminacao_L1", new List<Machine> { extrusM1_L1, corteM1_L1, corteM2_L1 });

        var wc_Aciaria_L2 = new WorkCenter("Aciaria_L2", new List<Machine> { fusaoM1_L2, aquecM1_L2 });
        var wc_Lam_L2 = new WorkCenter("Laminacao_L2", new List<Machine> { extrusM1_L2, corteM1_L2 });

        // --- Definição das Linhas (Sequência de WCs importa aqui) ---
        var line1 = new Line("Predio_01", new List<WorkCenter> { wc_Aciaria_L1, wc_Lam_L1 }, new[] { "VAT30", "VD500", "SX650" });
        var line2 = new Line("Predio_02", new List<WorkCenter> { wc_Aciaria_L2, wc_Lam_L2 }, new[] { "NEWPROD" });
        var lines = new List<Line> { line1, line2 };

        // --- Definição dos Produtos com Rotas (Sequência de TIPOS de máquina importa) ---
        var rotaPadrao = new List<string> { "Fusao", "Aquecimento", "Extrusao", "Corte" };
        var products = new List<Product>
        {
            new Product("VAT30", 100, 50, rotaPadrao), // 100 tons
            new Product("VD500", 100, 60, rotaPadrao), // 100 tons
            new Product("SX650", 100, 70, rotaPadrao), // 100 tons
            new Product("NEWPROD", 50, 80, rotaPadrao)  // 50 tons
        };

        // --- Criação do Modelo ---
        var model = new CpModel();

        // --- Dicionários para Armazenar Variáveis e Dados Auxiliares ---
        var productIsScheduled = new Dictionary<string, BoolVar>();
        var assignProdToLine = new Dictionary<(string productName, string lineName), BoolVar>();
        var assignStepToMachine = new Dictionary<(string prod, int step, string mach), BoolVar>();
        var stepStartVars = new Dictionary<(string prod, int step, string mach), IntVar>();
        var stepEndVars = new Dictionary<(string prod, int step, string mach), IntVar>();
        var stepIntervalVars = new Dictionary<(string prod, int step, string mach), IntervalVar>();
        var wcIntervalVars = new Dictionary<(string prod, string wcName), IntervalVar>(); // Intervalos por WC
        var wcStartVars = new Dictionary<(string prod, string wcName), IntVar>(); // Início no WC
        var wcEndVars = new Dictionary<(string prod, string wcName), IntVar>(); // Fim no WC
        var finishedByDeadlineVars = new Dictionary<string, BoolVar>();

        // Mapeamento: (produto, etapa_idx) -> wc onde a etapa ocorre
        var stepToWcMap = new Dictionary<(string prod, int step), WorkCenter>();
        // Mapeamento: (produto, wc) -> lista de (etapa_idx, tipo_maquina) que ocorrem nesse WC
        var wcToStepsMap = new Dictionary<(string prod, string wcName), List<(int stepIdx, string machineType)>>();


        // --- Criação das Variáveis de Decisão ---

        foreach (var product in products)
        {
            var productName = product.Name;
            productIsScheduled[productName] = model.NewBoolVar($"IsScheduled_{productName}");
            finishedByDeadlineVars[productName] = model.NewBoolVar($"FinishedByDeadline_{productName}");

            var possibleLinesForProduct = new List<BoolVar>();
            var productRoute = product.Route;

            // 1. Atribuição Produto -> Linha
            foreach (var line in lines)
            {
                if (line.AllowedProducts.Contains(productName))
                {
                    var lineAssignVar = model.NewBoolVar($"Assign_{productName}_To_{line.Name}");
                    assignProdToLine[(productName, line.Name)] = lineAssignVar;
                    possibleLinesForProduct.Add(lineAssignVar);
                }
            }
            if (possibleLinesForProduct.Any())
            {
                model.Add(LinearExpr.Sum(possibleLinesForProduct) == 1).OnlyEnforceIf(productIsScheduled[productName]);
                model.Add(LinearExpr.Sum(possibleLinesForProduct) == 0).OnlyEnforceIf(productIsScheduled[productName].Not());
            }
            else
            {
                Console.WriteLine($"AVISO: Produto {productName} não é permitido em nenhuma linha. Não será agendado.");
                model.Add(productIsScheduled[productName] == 0);
                continue;
            }

            // 2. Variáveis de Etapa (Máquina) e Mapeamento Etapa -> WC
            var stepsInWc = new Dictionary<string, List<(int stepIdx, string machineType)>>();
            bool possibleToSchedule = true;
            for (int step = 0; step < productRoute.Count; step++)
            {
                string requiredMachineType = productRoute[step];
                var possibleMachinesForStep = new List<BoolVar>();
                WorkCenter wcForThisStep = null;

                int stepsOfSameTypeBefore = 0;
                for (int s = 0; s < step; ++s) { if (productRoute[s] == requiredMachineType) stepsOfSameTypeBefore++; }

                WorkCenter potentialWc = null;
                Line lineForThisStep = null;
                foreach (var line in lines.Where(l => l.AllowedProducts.Contains(productName)))
                {
                    int wcCountOfTypeFound = 0;
                    foreach (var wc in line.WorkCenters)
                    {
                        if (wc.GetMachinesOfType(requiredMachineType).Any())
                        {
                            if (wcCountOfTypeFound == stepsOfSameTypeBefore)
                            {
                                potentialWc = wc;
                                lineForThisStep = line;
                                break;
                            }
                            wcCountOfTypeFound++;
                        }
                    }
                    if (potentialWc != null) break;
                }

                if (potentialWc == null)
                {
                    Console.WriteLine($"AVISO: Produto {productName}, Etapa {step} ({requiredMachineType}) - Não foi possível encontrar um WC correspondente na sequência das linhas permitidas.");
                    possibleToSchedule = false;
                    break;
                }
                wcForThisStep = potentialWc;
                stepToWcMap[(productName, step)] = wcForThisStep;

                if (!stepsInWc.ContainsKey(wcForThisStep.Name)) stepsInWc[wcForThisStep.Name] = new List<(int stepIdx, string machineType)>();
                stepsInWc[wcForThisStep.Name].Add((step, requiredMachineType));

                var lineAssignVar = assignProdToLine[(productName, lineForThisStep.Name)];
                var eligibleMachinesInWc = wcForThisStep.GetMachinesOfType(requiredMachineType);

                // *** INÍCIO DA CORREÇÃO DE PARALELISMO ***
                // Calcula a capacidade total para este tipo de máquina neste WC
                decimal totalCapacityOfTypeInWC = wcForThisStep.GetTotalCapacityForType(requiredMachineType);
                if (totalCapacityOfTypeInWC <= 0)
                {
                    Console.WriteLine($"ERRO: Capacidade total zero ou negativa para tipo {requiredMachineType} no WC {wcForThisStep.Name}.");
                    possibleToSchedule = false;
                    break; // Não pode continuar se a capacidade for inválida
                }

                // Calcula a duração baseada na capacidade TOTAL (paralela)
                long duration = Math.Max(1, (long)Math.Ceiling(product.Quantity / totalCapacityOfTypeInWC * 60M));
                if (duration <= 0) duration = 1; // Garante duração positiva
                // *** FIM DA CORREÇÃO DE PARALELISMO ***

                foreach (var machine in eligibleMachinesInWc)
                {
                    var machineName = machine.Name;
                    var stepMachineAssignVar = model.NewBoolVar($"Assign_{productName}_Step{step}_To_{machineName}");
                    assignStepToMachine[(productName, step, machineName)] = stepMachineAssignVar;
                    possibleMachinesForStep.Add(stepMachineAssignVar);

                    model.AddImplication(stepMachineAssignVar, lineAssignVar);

                    // Usa a duração calculada com base na capacidade total (paralela)
                    var start = model.NewIntVar(0, planningHorizonMinutes, $"Start_{productName}_Step{step}_{machineName}");
                    var end = model.NewIntVar(0, planningHorizonMinutes, $"End_{productName}_Step{step}_{machineName}");
                    // Cria o intervalo com a duração ajustada para paralelismo
                    var interval = model.NewOptionalIntervalVar(start, duration, end, stepMachineAssignVar, $"Interval_{productName}_Step{step}_{machineName}");

                    stepStartVars[(productName, step, machineName)] = start;
                    stepEndVars[(productName, step, machineName)] = end;
                    stepIntervalVars[(productName, step, machineName)] = interval;
                }

                if (possibleMachinesForStep.Any())
                {
                    model.Add(LinearExpr.Sum(possibleMachinesForStep) == 1).OnlyEnforceIf(productIsScheduled[productName]);
                }
                else
                {
                    // Esta verificação agora é redundante devido à verificação de capacidade total acima
                    // Console.WriteLine($"AVISO: Produto {productName} não tem máquinas elegíveis para a etapa {step} ({requiredMachineType}) no WC {wcForThisStep.Name}. Não poderá ser agendado.");
                    possibleToSchedule = false;
                    break;
                }
            }

            if (!possibleToSchedule)
            {
                model.Add(productIsScheduled[productName] == 0);
                continue;
            }

            foreach (var kvp in stepsInWc) { wcToStepsMap[(productName, kvp.Key)] = kvp.Value; }

            // 3. Variáveis de WorkCenter
            var productWcs = stepToWcMap
                .Where(kvp => kvp.Key.prod == productName)
                .Select(kvp => kvp.Value)
                .Distinct()
                .ToList();

            foreach (var wc in productWcs)
            {
                var wcName = wc.Name;
                if (!wcToStepsMap.ContainsKey((productName, wcName))) continue;
                var wcSteps = wcToStepsMap[(productName, wcName)];

                var wcStart = model.NewIntVar(0, planningHorizonMinutes, $"WCStart_{productName}_{wcName}");
                var wcEnd = model.NewIntVar(0, planningHorizonMinutes, $"WCEnd_{productName}_{wcName}");
                wcStartVars[(productName, wcName)] = wcStart;
                wcEndVars[(productName, wcName)] = wcEnd;

                var wcDuration = model.NewIntVar(0, planningHorizonMinutes, $"WCDuration_{productName}_{wcName}");
                model.Add(wcDuration == wcEnd - wcStart).OnlyEnforceIf(productIsScheduled[productName]);
                model.Add(wcDuration == 0).OnlyEnforceIf(productIsScheduled[productName].Not());

                var wcInterval = model.NewOptionalIntervalVar(wcStart, wcDuration, wcEnd, productIsScheduled[productName], $"WCInterval_{productName}_{wcName}");
                wcIntervalVars[(productName, wcName)] = wcInterval;

                var relevantMachineStarts = new List<IntVar>();
                var relevantMachineEnds = new List<IntVar>();

                foreach (var (stepIdx, machineType) in wcSteps)
                {
                    foreach (var machine in wc.GetMachinesOfType(machineType))
                    {
                        var key = (productName, stepIdx, machine.Name);
                        if (stepStartVars.ContainsKey(key))
                        {
                            relevantMachineStarts.Add(stepStartVars[key]);
                            relevantMachineEnds.Add(stepEndVars[key]);
                        }
                    }
                }

                if (!relevantMachineStarts.Any())
                {
                    Console.WriteLine($"AVISO: Produto {productName} não tem máquinas definidas para o WC {wcName}. Verifique a configuração.");
                    model.Add(productIsScheduled[productName] == 0);
                    continue;
                }

                var wcActualStart = model.NewIntVar(0, planningHorizonMinutes, $"WCActualStart_{productName}_{wcName}");
                var wcActualEnd = model.NewIntVar(0, planningHorizonMinutes, $"WCActualEnd_{productName}_{wcName}");

                model.AddMinEquality(wcActualStart, relevantMachineStarts);
                model.AddMaxEquality(wcActualEnd, relevantMachineEnds);

                model.Add(wcStart == wcActualStart).OnlyEnforceIf(productIsScheduled[productName]);
                model.Add(wcEnd == wcActualEnd).OnlyEnforceIf(productIsScheduled[productName]);
                model.Add(wcStart == 0).OnlyEnforceIf(productIsScheduled[productName].Not());
                model.Add(wcEnd == 0).OnlyEnforceIf(productIsScheduled[productName].Not());
            }
        }


        // --- Restrições ---

        // 1. Sequência da Rota (Entre máquinas da mesma etapa e etapas diferentes)
        foreach (var product in products)
        {
            var productName = product.Name;
            var productRoute = product.Route;
            var isScheduledVar = productIsScheduled[productName];

            for (int step = 0; step < productRoute.Count - 1; step++)
            {
                if (!stepToWcMap.TryGetValue((productName, step), out var currentWc) ||
                    !stepToWcMap.TryGetValue((productName, step + 1), out var nextWc))
                {
                    continue;
                }

                var currentStepEndVars = new List<IntVar>();
                var nextStepStartVars = new List<IntVar>();

                string currentMachineType = productRoute[step];
                foreach (var machine in currentWc.GetMachinesOfType(currentMachineType))
                {
                    var key = (productName, step, machine.Name);
                    if (stepEndVars.ContainsKey(key)) currentStepEndVars.Add(stepEndVars[key]);
                }

                string nextMachineType = productRoute[step + 1];
                foreach (var machine in nextWc.GetMachinesOfType(nextMachineType))
                {
                    var key = (productName, step + 1, machine.Name);
                    if (stepStartVars.ContainsKey(key)) nextStepStartVars.Add(stepStartVars[key]);
                }

                if (!currentStepEndVars.Any() || !nextStepStartVars.Any())
                {
                    continue;
                }

                var actualStepEnd = model.NewIntVar(0, planningHorizonMinutes, $"ActualEnd_{productName}_Step{step}");
                var actualStepStart = model.NewIntVar(0, planningHorizonMinutes, $"ActualStart_{productName}_Step{step + 1}");

                model.AddMaxEquality(actualStepEnd, currentStepEndVars);
                model.AddMinEquality(actualStepStart, nextStepStartVars);

                model.Add(actualStepStart >= actualStepEnd).OnlyEnforceIf(isScheduledVar);
            }
        }

        // 2. Não Sobreposição em Máquinas Individuais (R1) - SEM SETUP AQUI
        var allMachinesDict = lines.SelectMany(l => l.GetAllMachines()).Distinct().ToDictionary(m => m.Name);
        var machineSteps = new Dictionary<string, List<(string prod, int step, IntervalVar interval, BoolVar assignVar)>>();

        // Agrupa etapas por máquina
        foreach (var kvp in stepIntervalVars)
        {
            string machineName = kvp.Key.mach;
            if (!machineSteps.ContainsKey(machineName)) machineSteps[machineName] = new List<(string prod, int step, IntervalVar interval, BoolVar assignVar)>();
            machineSteps[machineName].Add((kvp.Key.prod, kvp.Key.step, kvp.Value, assignStepToMachine[kvp.Key]));
        }

        // Adiciona restrições de não sobreposição por máquina
        foreach (var kvp in machineSteps)
        {
            if (kvp.Value.Count > 1)
            {
                model.AddNoOverlap(kvp.Value.Select(s => s.interval));
            }
            // Lógica de setup removida daqui
        }


        // 3. Não Sobreposição e Setup em WorkCenters (R2, C7, C8 - Setup no WC)
        var wcIntervalsByWc = new Dictionary<string, List<(string prod, IntervalVar interval)>>();
        foreach (var kvp in wcIntervalVars)
        {
            string wcName = kvp.Key.wcName;
            if (!wcIntervalsByWc.ContainsKey(wcName)) wcIntervalsByWc[wcName] = new List<(string prod, IntervalVar interval)>();
            wcIntervalsByWc[wcName].Add((kvp.Key.prod, kvp.Value));
        }

        foreach (var kvp in wcIntervalsByWc)
        {
            var wcName = kvp.Key;
            var intervalsInWc = kvp.Value;
            if (intervalsInWc.Count > 1)
            {
                // 3a. Não Sobreposição no WC (R2, C7)
                model.AddNoOverlap(intervalsInWc.Select(i => i.interval));

                // 3b. Tempo de Setup na Troca de Produto no WC (C8)
                for (int i = 0; i < intervalsInWc.Count; i++)
                {
                    for (int j = i + 1; j < intervalsInWc.Count; j++)
                    {
                        var intervalInfo1 = intervalsInWc[i];
                        var intervalInfo2 = intervalsInWc[j];

                        // Setup só se aplica se os PRODUTOS forem diferentes
                        if (intervalInfo1.prod == intervalInfo2.prod) continue;

                        var interval1 = intervalInfo1.interval;
                        var interval2 = intervalInfo2.interval;
                        var start1 = wcStartVars[(intervalInfo1.prod, wcName)];
                        var end1 = wcEndVars[(intervalInfo1.prod, wcName)];
                        var start2 = wcStartVars[(intervalInfo2.prod, wcName)];
                        var end2 = wcEndVars[(intervalInfo2.prod, wcName)];

                        var pres1 = productIsScheduled[intervalInfo1.prod];
                        var pres2 = productIsScheduled[intervalInfo2.prod];

                        var wc1BeforeWc2 = model.NewBoolVar($"WC_{wcName}_{intervalInfo1.prod}_Before_{intervalInfo2.prod}");

                        int setupTime12 = CalculateWcSetupTime(products.First(p => p.Name == intervalInfo2.prod), wcName, wcToStepsMap, stepToWcMap);
                        int setupTime21 = CalculateWcSetupTime(products.First(p => p.Name == intervalInfo1.prod), wcName, wcToStepsMap, stepToWcMap);

                        model.Add(start2 >= end1 + setupTime12).OnlyEnforceIf(new ILiteral[] { pres1, pres2, wc1BeforeWc2 });
                        model.Add(start1 >= end2 + setupTime21).OnlyEnforceIf(new ILiteral[] { pres1, pres2, wc1BeforeWc2.Not() });
                        model.Add(start2 >= end1).OnlyEnforceIf(new ILiteral[] { pres1, pres2, wc1BeforeWc2 });
                        model.Add(start1 >= end2).OnlyEnforceIf(new ILiteral[] { pres1, pres2, wc1BeforeWc2.Not() });
                    }
                }
            }
        }


        // 4. Sequência de WorkCenters (C5, C6)
        foreach (var product in products)
        {
            var productName = product.Name;
            var isScheduledVar = productIsScheduled[productName];

            foreach (var line in lines.Where(l => l.AllowedProducts.Contains(productName)))
            {
                var lineAssignVar = assignProdToLine[(productName, line.Name)];
                var wcsInLine = line.WorkCenters;

                for (int wcIdx = 0; wcIdx < wcsInLine.Count - 1; wcIdx++)
                {
                    var currentWc = wcsInLine[wcIdx];
                    var nextWc = wcsInLine[wcIdx + 1];

                    if (wcEndVars.ContainsKey((productName, currentWc.Name)) &&
                        wcStartVars.ContainsKey((productName, nextWc.Name)))
                    {
                        model.Add(wcStartVars[(productName, nextWc.Name)] >= wcEndVars[(productName, currentWc.Name)])
                             .OnlyEnforceIf(new ILiteral[] { isScheduledVar, lineAssignVar });
                    }
                }
            }
        }


        // 5. Restrições de Deadline (R4 - Usando Início/Fim GLOBAIS do produto)
        foreach (var product in products)
        {
            var productName = product.Name;
            var isScheduledVar = productIsScheduled[productName];
            var finishedVar = finishedByDeadlineVars[productName];

            IntVar productStartTime = null;
            IntVar productEndTime = null;
            var relevantWcStarts = new List<IntVar>();
            var relevantWcEnds = new List<IntVar>();

            foreach (var line in lines.Where(l => l.AllowedProducts.Contains(productName)))
            {
                var lineAssignVar = assignProdToLine[(productName, line.Name)];
                WorkCenter firstWcOnLine = null;
                WorkCenter lastWcOnLine = null;

                for (int step = 0; step < product.Route.Count; ++step)
                {
                    if (stepToWcMap.TryGetValue((productName, step), out var wcForStep) && line.WorkCenters.Contains(wcForStep))
                    {
                        if (firstWcOnLine == null || line.WorkCenters.IndexOf(wcForStep) < line.WorkCenters.IndexOf(firstWcOnLine)) firstWcOnLine = wcForStep;
                        if (lastWcOnLine == null || line.WorkCenters.IndexOf(wcForStep) > line.WorkCenters.IndexOf(lastWcOnLine)) lastWcOnLine = wcForStep;
                    }
                }

                if (firstWcOnLine != null && lastWcOnLine != null &&
                    wcStartVars.ContainsKey((productName, firstWcOnLine.Name)) &&
                    wcEndVars.ContainsKey((productName, lastWcOnLine.Name)))
                {
                    var startIfLine = model.NewIntVar(0, planningHorizonMinutes, $"StartIf_{line.Name}_{productName}");
                    model.Add(startIfLine == wcStartVars[(productName, firstWcOnLine.Name)]).OnlyEnforceIf(lineAssignVar);
                    model.Add(startIfLine == 0).OnlyEnforceIf(lineAssignVar.Not());
                    relevantWcStarts.Add(startIfLine);

                    var endIfLine = model.NewIntVar(0, planningHorizonMinutes, $"EndIf_{line.Name}_{productName}");
                    model.Add(endIfLine == wcEndVars[(productName, lastWcOnLine.Name)]).OnlyEnforceIf(lineAssignVar);
                    model.Add(endIfLine == 0).OnlyEnforceIf(lineAssignVar.Not());
                    relevantWcEnds.Add(endIfLine);
                }
            }

            if (relevantWcStarts.Any() && relevantWcEnds.Any())
            {
                productStartTime = model.NewIntVar(0, planningHorizonMinutes, $"ProductStart_{productName}");
                productEndTime = model.NewIntVar(0, planningHorizonMinutes, $"ProductEnd_{productName}");
                model.AddMaxEquality(productStartTime, relevantWcStarts);
                model.AddMaxEquality(productEndTime, relevantWcEnds);

                var endTimeLEDeadlineVar = model.NewBoolVar($"EndTimeLEDeadline_{productName}");
                model.Add(productEndTime <= deadlineMinutes).OnlyEnforceIf(endTimeLEDeadlineVar);
                model.Add(productEndTime > deadlineMinutes).OnlyEnforceIf(endTimeLEDeadlineVar.Not());
                model.AddBoolAnd(new[] { isScheduledVar, endTimeLEDeadlineVar }).OnlyEnforceIf(finishedVar);
                model.AddImplication(finishedVar, isScheduledVar);
                model.AddImplication(finishedVar, endTimeLEDeadlineVar);

                var startTimeGTDeadlineVar = model.NewBoolVar($"StartTimeGTDeadline_{productName}");
                model.Add(productStartTime > deadlineMinutes).OnlyEnforceIf(startTimeGTDeadlineVar);
                model.Add(productStartTime <= deadlineMinutes).OnlyEnforceIf(startTimeGTDeadlineVar.Not());

                if (permitirAtraso)
                {
                    model.AddImplication(isScheduledVar, startTimeGTDeadlineVar.Not());
                }
                else
                {
                    model.AddImplication(isScheduledVar, finishedVar);
                }
            }
            else
            {
                model.Add(finishedVar == 0);
            }
        }


        // --- Função Objetivo ---
        LinearExpr objective = LinearExpr.Sum(products.Select(p =>
            finishedByDeadlineVars.ContainsKey(p.Name) ? finishedByDeadlineVars[p.Name] * p.Price : LinearExpr.Constant(0)
        ));
        model.Maximize(objective);


        // --- Resolve ---
        var solver = new CpSolver();
        solver.StringParameters = "max_time_in_seconds:120.0; log_search_progress: false; num_workers: 8;";
        Console.WriteLine("Iniciando solver...");
        var status = solver.Solve(model);
        Console.WriteLine("Solver finalizado.");

        // --- Coleta de Dados para JSON ---
        var timelineOutput = new TimelineOutput();
        var allMachineEntries = new List<MachineEntry>();

        if (status == CpSolverStatus.Optimal || status == CpSolverStatus.Feasible)
        {
            foreach (var product in products)
            {
                var productName = product.Name;
                if (!productIsScheduled.TryGetValue(productName, out var scheduledVar) || solver.Value(scheduledVar) != 1)
                    continue;

                for (int step = 0; step < product.Route.Count; step++)
                {
                    string requiredType = product.Route[step];
                    if (stepToWcMap.TryGetValue((productName, step), out var wcForStep))
                    {
                        foreach (var machine in wcForStep.GetMachinesOfType(requiredType))
                        {
                            var key = (productName, step, machine.Name);
                            if (assignStepToMachine.TryGetValue(key, out var assignStepVar) && solver.Value(assignStepVar) == 1)
                            {
                                if (stepStartVars.TryGetValue(key, out var sVar) && stepEndVars.TryGetValue(key, out var eVar))
                                {
                                    long startMin = solver.Value(sVar);
                                    long endMin = solver.Value(eVar);
                                    DateTime startTime = startDate.AddMinutes(startMin);
                                    DateTime endTime = startDate.AddMinutes(endMin);
                                    double delay = Math.Max(0, (endTime - deadlineDate).TotalMinutes);

                                    allMachineEntries.Add(new MachineEntry
                                    {
                                        Product = productName,
                                        Machine = machine.Name,
                                        StartTime = startTime.ToString(DateTimeFormat, CultureInfo.InvariantCulture),
                                        EndTime = endTime.ToString(DateTimeFormat, CultureInfo.InvariantCulture),
                                        Delay = Math.Round(delay, 2)
                                    });
                                }
                                break;
                            }
                        }
                    }
                }
            }

            allMachineEntries.Sort((a, b) => DateTime.ParseExact(a.StartTime, DateTimeFormat, CultureInfo.InvariantCulture)
                                        .CompareTo(DateTime.ParseExact(b.StartTime, DateTimeFormat, CultureInfo.InvariantCulture)));

            var lineData = new Dictionary<string, LineEntry>();

            foreach (var machineEntry in allMachineEntries)
            {
                string lineName = null;
                string wcName = null;
                Line foundLine = null;
                WorkCenter foundWc = null;

                foreach (var line in lines)
                {
                    foreach (var wc in line.WorkCenters)
                    {
                        if (wc.Machines.Any(m => m.Name == machineEntry.Machine))
                        {
                            lineName = line.Name;
                            wcName = wc.Name;
                            foundLine = line;
                            foundWc = wc;
                            goto FoundLocation;
                        }
                    }
                }

            FoundLocation:
                if (lineName == null || wcName == null) continue;

                if (!lineData.TryGetValue(lineName, out var lineEntry))
                {
                    lineEntry = new LineEntry { Line = lineName };
                    lineData[lineName] = lineEntry;
                }

                var wcEntry = lineEntry.WorkCenters.FirstOrDefault(w => w.WorkCenter == wcName);
                if (wcEntry == null)
                {
                    wcEntry = new WorkCenterEntry { WorkCenter = wcName };
                    lineEntry.WorkCenters.Add(wcEntry);
                }
                wcEntry.Machines.Add(machineEntry);
            }

            foreach (var lineEntry in lineData.Values)
            {
                DateTime lineStartTime = DateTime.MaxValue;
                DateTime lineEndTime = DateTime.MinValue;

                foreach (var wcEntry in lineEntry.WorkCenters)
                {
                    if (wcEntry.Machines.Any())
                    {
                        wcEntry.Machines.Sort((a, b) => DateTime.ParseExact(a.StartTime, DateTimeFormat, CultureInfo.InvariantCulture)
                                                  .CompareTo(DateTime.ParseExact(b.StartTime, DateTimeFormat, CultureInfo.InvariantCulture)));

                        var wcStartTimeDt = DateTime.ParseExact(wcEntry.Machines.First().StartTime, DateTimeFormat, CultureInfo.InvariantCulture);
                        var wcEndTimeDt = DateTime.ParseExact(wcEntry.Machines.Last().EndTime, DateTimeFormat, CultureInfo.InvariantCulture);

                        wcEntry.StartTime = wcStartTimeDt.ToString(DateTimeFormat, CultureInfo.InvariantCulture);
                        wcEntry.EndTime = wcEndTimeDt.ToString(DateTimeFormat, CultureInfo.InvariantCulture);
                        wcEntry.Delay = Math.Round(Math.Max(0, (wcEndTimeDt - deadlineDate).TotalMinutes), 2);

                        if (wcStartTimeDt < lineStartTime) lineStartTime = wcStartTimeDt;
                        if (wcEndTimeDt > lineEndTime) lineEndTime = wcEndTimeDt;
                    }
                }

                lineEntry.WorkCenters.Sort((a, b) => {
                    if (string.IsNullOrEmpty(a.StartTime)) return 1;
                    if (string.IsNullOrEmpty(b.StartTime)) return -1;
                    return DateTime.ParseExact(a.StartTime, DateTimeFormat, CultureInfo.InvariantCulture)
                           .CompareTo(DateTime.ParseExact(b.StartTime, DateTimeFormat, CultureInfo.InvariantCulture));
                });


                if (lineStartTime != DateTime.MaxValue)
                {
                    lineEntry.StartTime = lineStartTime.ToString(DateTimeFormat, CultureInfo.InvariantCulture);
                    lineEntry.EndTime = lineEndTime.ToString(DateTimeFormat, CultureInfo.InvariantCulture);
                    lineEntry.Delay = Math.Round(Math.Max(0, (lineEndTime - deadlineDate).TotalMinutes), 2);
                }
            }

            timelineOutput.TimeLine = lineData.Values
                                        .OrderBy(l => {
                                            if (string.IsNullOrEmpty(l.StartTime)) return DateTime.MaxValue;
                                            return DateTime.ParseExact(l.StartTime, DateTimeFormat, CultureInfo.InvariantCulture);
                                        })
                                        .ToList();
        }


        // --- Exibe Resultados Console (Título atualizado) ---
        if (status == CpSolverStatus.Optimal || status == CpSolverStatus.Feasible)
        {
            Console.WriteLine("\n--- Resultado do Agendamento (Paralelismo Corrigido) ---"); // Título atualizado
            Console.WriteLine($"Status do Solver: {status}");
            Console.WriteLine($"Data de Início do Planejamento: {startDate.ToString(DateTimeFormat)}");
            Console.WriteLine($"Deadline: {deadlineDate.ToString(DateTimeFormat)} (Minuto {deadlineMinutes})");
            Console.WriteLine($"Permitir Atraso: {(permitirAtraso ? "SIM" : "NÃO")}");
            Console.WriteLine($"Valor Objetivo (Lucro Máximo): {solver.ObjectiveValue}\n");

            var sortedProducts = products.OrderBy(p => p.Name);

            foreach (var product in sortedProducts)
            {
                var productName = product.Name;
                bool scheduled = productIsScheduled.TryGetValue(productName, out var scheduledVar) &&
                                 solver.Value(scheduledVar) == 1;

                if (scheduled)
                {
                    string assignedLineName = "N/A";
                    foreach (var line in lines)
                    {
                        if (assignProdToLine.TryGetValue((productName, line.Name), out var assignVar) &&
                            solver.Value(assignVar) == 1)
                        {
                            assignedLineName = line.Name;
                            break;
                        }
                    }

                    bool finishedOnTime = finishedByDeadlineVars.TryGetValue(productName, out var finVar) &&
                                    solver.Value(finVar) == 1;

                    string productStatus;
                    if (finishedOnTime) { productStatus = "FINALIZADO (dentro do deadline)"; }
                    else { productStatus = permitirAtraso ? "CONCLUÍDO (com atraso)" : "ERRO LÓGICO (Agendado sem permitir atraso)"; }

                    Console.WriteLine($"Produto: {productName} (Linha: {assignedLineName})");
                    Console.WriteLine($"  Status: {productStatus}");
                    if (finishedOnTime) Console.WriteLine($"  Lucro Contribuído (base): {product.Price}");

                    long productStartMin = -1;
                    long productEndMin = -1;
                    DateTime productStartTime = DateTime.MinValue;
                    DateTime productEndTime = DateTime.MinValue;

                    Line assignedLine = lines.FirstOrDefault(l => l.Name == assignedLineName);
                    WorkCenter firstWc = null;
                    WorkCenter lastWc = null;
                    if (assignedLine != null)
                    {
                        for (int step = 0; step < product.Route.Count; ++step)
                        {
                            if (stepToWcMap.TryGetValue((productName, step), out var wcForStep) && assignedLine.WorkCenters.Contains(wcForStep))
                            {
                                if (firstWc == null || assignedLine.WorkCenters.IndexOf(wcForStep) < assignedLine.WorkCenters.IndexOf(firstWc)) firstWc = wcForStep;
                                if (lastWc == null || assignedLine.WorkCenters.IndexOf(wcForStep) > assignedLine.WorkCenters.IndexOf(lastWc)) lastWc = wcForStep;
                            }
                        }
                    }

                    if (firstWc != null && lastWc != null &&
                        wcStartVars.TryGetValue((productName, firstWc.Name), out var startVar) &&
                        wcEndVars.TryGetValue((productName, lastWc.Name), out var endVar))
                    {
                        productStartMin = solver.Value(startVar);
                        productEndMin = solver.Value(endVar);
                        productStartTime = startDate.AddMinutes(productStartMin);
                        productEndTime = startDate.AddMinutes(productEndMin);
                    }

                    for (int step = 0; step < product.Route.Count; step++)
                    {
                        string requiredType = product.Route[step];
                        string assignedMachineName = "N/A";
                        long startMin = -1, endMin = -1;
                        DateTime startTime = DateTime.MinValue, endTime = DateTime.MinValue;

                        if (stepToWcMap.TryGetValue((productName, step), out var wcForStep))
                        {
                            foreach (var machine in wcForStep.GetMachinesOfType(requiredType))
                            {
                                var key = (productName, step, machine.Name);
                                if (assignStepToMachine.TryGetValue(key, out var assignStepVar) && solver.Value(assignStepVar) == 1)
                                {
                                    assignedMachineName = machine.Name;
                                    if (stepStartVars.TryGetValue(key, out var sVar) && stepEndVars.TryGetValue(key, out var eVar))
                                    {
                                        startMin = solver.Value(sVar);
                                        endMin = solver.Value(eVar);
                                        startTime = startDate.AddMinutes(startMin);
                                        endTime = startDate.AddMinutes(endMin);
                                    }
                                    break;
                                }
                            }
                        }
                        Console.WriteLine($"    Etapa {step} ({requiredType}) -> Máquina: {assignedMachineName} | {startTime.ToString(DateTimeFormat)} (Min {startMin}) -> {endTime.ToString(DateTimeFormat)} (Min {endMin})");
                    }

                    Console.WriteLine($"  Início real do produto: {productStartTime.ToString(DateTimeFormat)} (Minuto {productStartMin})");
                    Console.WriteLine($"  Fim real do produto: {productEndTime.ToString(DateTimeFormat)} (Minuto {productEndMin})");

                    if (!finishedOnTime && productEndMin >= 0)
                    {
                        TimeSpan atraso = productEndTime - deadlineDate;
                        if (atraso.TotalMinutes > 0)
                        {
                            Console.WriteLine($"  Tempo de Atraso: {Math.Round(atraso.TotalMinutes)} minutos ({atraso.Days}d {atraso.Hours}h {atraso.Minutes}m)");
                        }
                    }
                }
                else
                {
                    Console.WriteLine($"Produto: {productName}");
                    bool canBeMade = products.Any(p => p.Name == productName &&
                                                     lines.Any(l => l.AllowedProducts.Contains(productName) &&
                                                                    p.Route.All(rt => l.GetEligibleMachinesForTypeByWC(rt).Any())));
                    if (!canBeMade) { Console.WriteLine($"  Status: NÃO AGENDADO (Impossível fabricar - verifique rota/máquinas/linhas)"); }
                    else if (!permitirAtraso) { Console.WriteLine($"  Status: NÃO AGENDADO (Terminaria após deadline ou não lucrativo)"); }
                    else { Console.WriteLine($"  Status: NÃO AGENDADO (Não lucrativo ou conflito irresolvível)"); }
                }
                Console.WriteLine();
            }
        }
        else
        {
            Console.WriteLine("\nNenhuma solução viável encontrada ou solução ótima não encontrada dentro do tempo limite.");
            Console.WriteLine($"Status do Solver: {status}");
        }

        // --- Geração e Impressão do JSON ---
        try
        {
            string jsonOutput = JsonConvert.SerializeObject(timelineOutput, Formatting.Indented);
            Console.WriteLine("\n--- Saída JSON da Timeline ---");
            Console.WriteLine(jsonOutput);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"\nErro ao gerar JSON: {ex.Message}");
        }

        Console.WriteLine("\nTeste do Solver concluído. Pressione Enter para sair.");
        Console.ReadLine();
    }

    // Função auxiliar para calcular o tempo de setup na troca de produto em um WC
    private static int CalculateWcSetupTime(Product incomingProduct, string wcName,
                                            Dictionary<(string prod, string wcName), List<(int stepIdx, string machineType)>> wcToStepsMap,
                                            Dictionary<(string prod, int step), WorkCenter> stepToWcMap)
    {
        if (!wcToStepsMap.TryGetValue((incomingProduct.Name, wcName), out var stepsInWc) || !stepsInWc.Any())
        {
            return 0;
        }
        int firstStepIndexInWc = stepsInWc.Min(s => s.stepIdx);
        string firstMachineType = incomingProduct.Route[firstStepIndexInWc];
        if (!stepToWcMap.TryGetValue((incomingProduct.Name, firstStepIndexInWc), out var workCenter))
        {
            return 0;
        }
        if (workCenter.Name != wcName)
        {
            return 0;
        }
        return workCenter.GetMaxSetupTimeForType(firstMachineType);
    }
}
